mod comparator;
mod deserializer;
mod scanner;
mod serializer;

use clap::{App, Arg, SubCommand};
use comparator::{compare_nodes, DiffReport};
use deserializer::load_from_file;
use scanner::scan_directory;
use serializer::save_to_file;
use std::path::Path;

fn main() {
    let matches = App::new("DirInfo")
        .version("1.0")
        .author("anner@fanruan.com")
        .about("A tool to scan directories, generate binary files, and compare directory structures.")
        .subcommand(
            SubCommand::with_name("scan")
                .about("Scans a directory and generates a binary file containing its structure and file hashes.")
                .arg(
                    Arg::with_name("directory")
                        .required(true)
                        .takes_value(true)
                        .help("The directory to scan."),
                )
                .arg(
                    Arg::with_name("output")
                        .short("o")
                        .long("output")
                        .takes_value(true)
                        .help("The output file name (default: <directory_name>.info)."),
                )
                .arg(
                    Arg::with_name("exclude")
                        .short("e")
                        .long("exclude")
                        .takes_value(false)
                        .help("Regex pattern to exclude files/directories from scanning."),
                ),
        )
        .subcommand(
            SubCommand::with_name("compare")
                .about("Compares two binary files generated by the 'scan' command.")
                .arg(
                    Arg::with_name("file1")
                        .required(true)
                        .takes_value(true)
                        .help("The first binary file to compare."),
                )
                .arg(
                    Arg::with_name("file2")
                        .required(true)
                        .takes_value(true)
                        .help("The second binary file to compare."),
                )
                .arg(
                    Arg::with_name("exclude")
                        .short("e")
                        .long("exclude")
                        .takes_value(false)
                        .help("Regex pattern to exclude files/directories from comparison."),
                ),
        )
        .subcommand(
            SubCommand::with_name("show")
                .about("Displays the contents of a binary file generated by the 'scan' command.")
                .arg(
                    Arg::with_name("file")
                        .required(true)
                        .takes_value(true)
                        .help("The binary file to display."),
                ),
        )
        .subcommand(
            SubCommand::with_name("compare_dir")
                .about("Compares a binary file with the current directory structure.")
                .arg(
                    Arg::with_name("file")
                        .required(true)
                        .takes_value(true)
                        .help("The binary file to compare."),
                )
                .arg(
                    Arg::with_name("directory")
                        .required(true)
                        .takes_value(true)
                        .help("The directory to compare with."),
                )
                .arg(
                    Arg::with_name("exclude")
                        .short("e")
                        .long("exclude")
                        .takes_value(false)
                        .help("Regex pattern to exclude files/directories from comparison."),
                ),
        )
        .get_matches();

    match matches.subcommand() {
        ("scan", Some(scan_matches)) => {
            let path = scan_matches.value_of("directory").unwrap();
            let exclude_pattern = scan_matches.value_of("exclude").unwrap_or("");
            let default_output = {
                let dir_name = Path::new(path).file_name().unwrap().to_str().unwrap();
                format!("{}.info", dir_name) // Create the default output
            };
            let output_file = scan_matches
                .value_of("output")
                .unwrap_or_else(|| default_output.as_str());
            let node = scan_directory(Path::new(path), exclude_pattern);
            save_to_file(&node.unwrap(), output_file).expect("save file fail");
        }
        ("compare", Some(compare_matches)) => {
            let file1 = compare_matches.value_of("file1").unwrap();
            let file2 = compare_matches.value_of("file2").unwrap();
            let exclude_pattern = compare_matches.value_of("exclude").unwrap_or("");
            let node1 = load_from_file(file1);
            let node2 = load_from_file(file2);
            let mut report = DiffReport::new();
            compare_nodes(&node1, &node2, &mut report, exclude_pattern);
            print_diff_report(&report);
        }
        ("show", Some(extract_matches)) => {
            let file = extract_matches.value_of("file").unwrap();
            let node = load_from_file(file);
            println!("Extracted directory structure:");
            print_node(&node, 0);
        }
        ("compare_dir", Some(compare_dir_matches)) => {
            let file = compare_dir_matches.value_of("file").unwrap();
            let directory = compare_dir_matches.value_of("directory").unwrap();
            let exclude_pattern = compare_dir_matches.value_of("exclude").unwrap_or("");
            let node_file = load_from_file(file);
            let node_dir = scan_directory(Path::new(directory), exclude_pattern);
            let mut report = DiffReport::new();
            compare_nodes(&node_file, &node_dir.unwrap(), &mut report, exclude_pattern);
            print_diff_report(&report);
        }
        _ => {
            println!("No subcommand provided. Use --help for usage information.");
        }
    }
}

fn print_diff_report(report: &DiffReport) {
    println!("Differences found:");
    if !report.missing_in_left.is_empty() {
        println!("\nFiles/directories missing in left:");
        for path in &report.missing_in_left {
            println!("  - {}", path);
        }
    }
    if !report.missing_in_right.is_empty() {
        println!("\nFiles/directories missing in right:");
        for path in &report.missing_in_right {
            println!("  - {}", path);
        }
    }
    if !report.different_files.is_empty() {
        println!("\nFiles with different content:");
        for path in &report.different_files {
            println!("  - {}", path);
        }
    }
    if report.missing_in_left.is_empty()
        && report.missing_in_right.is_empty()
        && report.different_files.is_empty()
    {
        println!("No differences found.");
    }
}

fn print_node(node: &scanner::Node, indent: usize) {
    match node {
        scanner::Node::File { name, md5 } => {
            println!(
                "{:indent$}File: {} (MD5: {})",
                "",
                name,
                md5,
                indent = indent
            );
        }
        scanner::Node::Directory { name, children } => {
            println!("{:indent$}Directory: {}", "", name, indent = indent);
            for child in children {
                print_node(child.1, indent + 2);
            }
        }
    }
}
